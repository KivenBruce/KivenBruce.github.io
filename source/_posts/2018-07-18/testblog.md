---
title: Java基础系列(一)-运算符
date: 2018-07-18 16:33:14

tags: java

---

[一,java中的运算符]()

**1.自增与自减运算符**

i++,++i的区别:i++是取i的值,然后i=i+1; ++i是先将i=i+1,然后取i的值;

原则是:*如果放在变量之前，表示先自增/自减，然后再用这个值参与运算，如果是放在变量之后，则表示先计算表达式的值，之后再将变量自增/自减*

**2.逻辑运算符**

&&,||,!;分别叫做与,或,非;这三种很好理解,不多说;说一下java中的位运算符:&(与),|(或),~(非),^(异或)

两者之间容易混淆;逻辑运算符是针对两个关系运算符进行逻辑判断,而位运算符是针对两个二进制数进行逻辑运算;

2.1,与运算符

两个操作数中位都是1,结果才为1,否则为0

int a = 129;int b= 128;a&b=128;

“a”的值是129，转换成二进制就是10000001，而“b”的值是128，转换成二进制就是10000000。根据与运算符的运算规律，只有两个位都是1，结果才是1，可以知道结果就是10000000，即128。

<!--more-->

2.2,或运算符

两个位只要有一个为1，那么结果就是1，否则就为0

int a = 129;int b= 128;a|b=129;

“a”的值是129，转换成二进制就是10000001，而“b”的值是128，转换成二进制就是10000000。根据或运算符的运算规律，两个位只要有一个为1，那么结果就是1，可以知道结果就是10000001，即129。

2.3,非运算符  
非运算符用符号“~”表示，其运算规律如下：

如果位为0，结果是1，如果位为1，结果是0

2.4,异或运算符  
异或运算符是用符号“^”表示的，其运算规律是：

两个操作数的位中，相同则结果为0，不同则结果为1。

**3.移位运算符**

移位运算符操作的对象就是二进制的位，可以单独用移位运算符来处理int型整数

<<,左移运算符,相当于乘法;x<<3:x*(2^3)

'>>'右移运算符,相当于除法;x>>3:x/(2^3)

思考:结合以上所述,求两个大整数的平均值,考虑防止溢出;

(x&y)+((x^y)>>2);这种写法似乎不好理解

换一种写法如下:

  if((a^b)<0) {

```
avg=(a+b)/2;
```

  }else {

   if(a>=b)

```
   avg=b+(a-b)/2;
```

   else

```
   avg=a+(b-a)/2;
```

}

---

[二,Java中对象的克隆]()

克隆,自然就是讲对象重新复制一份;

看一个''灵异事件''

Person(String name,int age);//person对象有两个属性

Person person = new Person("kiven",20);

Person king = person;

king.setName("Jack");

king.setAge("30");

System.out.println(person.toString());

输出结果发现person中的name属性已经变了,变成了Jack;这是为什么呢?

Java中除了8中基本数据类型之外,剩下的为引用类型;

在这里,person与kng都是Person类对象的一个变量,他们并没有存储Person类对象的内容,只是存储了他们的地址,当我们把一个类对象赋值给另一个类对象变量,如king = person;只是把person对象地址赋值给了king,**所以person和king操作的是同一个对象;**

那么,如果我们只是想拷贝一个一模一样的对象,具有他所有的属性值,又不想使用new Person();每个属性赋值太麻烦了,该如何去做呢?

class Person implements Cloneable{

protected Object clone() throws CloneNotSupportedException {

```
Person p = null;  
p = (Person)super.clone();


return p;
```

}

}

Person king =(Person)person.clone();

三,java对象比较

Person person = new Person("kiven",20);

Person king = person;

king.equals(person);//true

king == person;//true
