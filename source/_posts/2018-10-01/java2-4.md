---
title: Java进阶系列(五)-Java GC
date: 2018-10-01 16:00:16
tags: java
---

java GC泛指java的垃圾回收机制，我们在日常写java代码的时候，一般都不需要编写内存回收或者垃圾清理的代码，也不需要像C/C++那样做类似delete/free的操作。JVM已经自动帮我们完成GC;但是写代码难免会遇到一些特殊情况，比如OOM,所以需要我们了解JVM是如何完成GC的;

接下来,我们需要了解如下问题:哪些内存要回收,什么时候回收,怎么回收.

<!--more-->

首先,我们要明白,JVM中GC帮我们自动管理内存的同时,GC是一种高开销的动作,所以我们应该尽量避免频繁的GC;

## 一,哪些内存要回收

java内存模型中分为五大区域已经有所了解。我们知道`程序计数器`、`虚拟机栈`、`本地方法栈`，由线程而生，随线程而灭，当方法或线程执行完毕后，内存就随着回收，因此无需关心。

而`Java堆`、`方法区`则不一样。方法区存放着类加载信息，但是一个接口中多个实现类需要的内存可能不太一样，一个方法中多个分支需要的内存也可能不一样【只有在运行期间才可知道这个方法创建了哪些对象没需要多少内存】，这部分内存的分配和回收都是动态的，gc关注的也正是这部分的内存。

为了高效的回收,jvm将堆分为三个区域:

```java
1.新生代（Young Generation）NewSize和MaxNewSize分别可以控制年轻代的初始大小和最大的大小
2.老年代（Old Generation）
3.永久代（Permanent Generation）【1.8以后采用元空间，就不在堆中了】
```

## 二,什么时候回收

简单的讲,就是GC算法区域满了或者将满了;

```java
minor GC(young GC):当年轻代中eden区分配满的时候触发[值得一提的是因为young GC后部分存活的对象会已到老年代(比如对象熬过15轮)，所以过后old gen的占用量通常会变高]

full GC:
①手动调用System.gc()方法 [增加了full GC频率，不建议使用而是让jvm自己管理内存，可以设置-XX:+ DisableExplicitGC来禁止RMI调用System.gc]
②发现perm gen（如果存在永久代的话)需分配空间但已经没有足够空间
③老年代空间不足，比如说新生代的大对象大数组晋升到老年代就可能导致老年代空间不足。
④CMS GC时出现Promotion Faield[pf]
⑤统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间。
这个比较难理解，这是HotSpot为了避免由于新生代晋升到老年代导致老年代空间不足而触发的FUll GC。
比如程序第一次触发Minor GC后，有5m的对象晋升到老年代，姑且现在平均算5m，那么下次Minor GC发生时，先判断现在老年代剩余空间大小是否超过5m，如果小于5m，则HotSpot则会触发full GC(这点挺智能的)
```

## 三,如何找到"垃圾"

```java
1.引用计数算法
早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。
优点:实现简单效率高，被广泛使用与如python何游戏脚本语言上。
缺点:难以解决循环引用的问题，就是假如两个对象互相引用已经不会再被其它其它引用，导致一直不会为0就无法进行回收。
注:由于该缺陷,主流的垃圾处理器都没有使用该方式判断"垃圾"

2.可达性分析算法
目前主流的商用语言[如java、c#]采用的是可达性分析算法判断对象是否存活。这个算法有效解决了循环利用的弊端。
它的基本思路是通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的。
```

注:即使可达性算法中不可达的对象，也不是一定要马上被回收;

```
要真正宣告对象死亡需经过两个过程。
1.可达性分析后没有发现引用链
2.查看对象是否有finalize方法，如果有重写且在方法内完成自救[比如再建立引用]，还是可以抢救一下，注意这边一个类的finalize只执行一次，这就会出现一样的代码第一次自救成功第二次失败的情况。[如果类重写finalize且还没调用过，会将这个对象放到一个叫做F-Queue的序列里，这边finalize不承诺一定会执行，这么做是因为如果里面死循环的话可能会时F-Queue队列处于等待，严重会导致内存崩溃，这是我们不希望看到的。]
```

## 四,如何进行垃圾回收

```java
1.标记/清除算法【最基础】
标记为"垃圾",GC清理有该标记的数据
不足:
标记和清除过程效率不高,并且产生大量不连续的内存空间,即"碎片",如果此时申请一个大空间的内存,而没有一个连续的大的内存空间释放,将再次除法GC;
2.复制算法
将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间;HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1;
不足：
将内存缩小为原来的一半，浪费了一半的内存空间，代价太高；如果不想浪费一半的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。适用于生命周期短的对象,即年轻代GC

3.标记/整理算法
标记—整理算法和标记—清除算法一样，但是标记—整理算法不是把存活对象复制到另一块内存，而是把存活对象往内存的一端移动，然后直接回收边界以外的内存，因此其不会产生内存碎片。标记—整理算法提高了内存的利用率，并且它适合在收集对象存活时间较长的老年代。
不足：
效率不高，不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法。
jvm采用`分代收集算法`对不同区域采用不同的回收算法。新生代采用复制算法,老年代采用标记/清除算法或标记/整理算法
```

## 五,GC分类

### 1.MinorGC(年轻代GC)

年轻代:尽可能的快速收集那些生命周期短的对象

![java2-4\monitorGC](java2-4\monitorGC.png)

### 2.FullGC(老年代GC)

FullGC一般也会触发年轻代的GC,FullGC比MinorGC慢,但是执行频率低

**注:程序中调用System.gc();可能会触发FullGC,但是不是一定的;慎用**

****更多GC详情,参考博文https://www.jianshu.com/p/76959115d486
